<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Temporal Echo Garden</title>
  <style>
    body {
      margin: 0;
      background: black;
      color: white;
      font-family: sans-serif;
      overflow: hidden;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.6);
      padding: 12px;
      border-radius: 10px;
      font-size: 14px;
      min-width: 200px;
    }
    button, input {
      margin-top: 5px;
      padding: 5px 10px;
      border-radius: 6px;
      border: none;
      background: #22c55e;
      color: white;
      cursor: pointer;
    }
    label {
      display:block;
      font-size:12px;
      margin-top:5px;
    }
  </style>
</head>
<body>

<div id="ui">
  <b>Temporal Echo Garden</b><br>

  状態: <span id="state">RUNNING</span><br>
  サイズ: <span id="size">15</span><br>
  スコア: <span id="score">0</span><br>
  エコー数: <span id="echoCount">0</span><br>

  <button onclick="togglePause()">ポーズ (P)</button>
  <button onclick="toggleReverse()">逆再生 (R)</button>
  <button onclick="resetGame()">リセット</button>

  <label>
    敵率: <span id="hostileLabel">50%</span>
    <input type="range" id="hostileSlider" min="0" max="100" value="50">
  </label>
</div>

<div id="logDisplay" style="
position:absolute;
bottom:30px;
left:50%;
transform:translateX(-50%);
background:rgba(0,0,0,0.7);
padding:15px;
border-radius:10px;
max-width:420px;
font-size:14px;
white-space:pre-line;
display:none;
"></div>

<canvas id="game"></canvas>

<script>
// ===== CANVAS =====

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// ===== AUDIO =====

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playTone(freq, duration=0.1, volume=0.05) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();

  osc.frequency.value = freq;
  osc.type = "sine";

  gain.gain.value = volume;

  osc.connect(gain);
  gain.connect(audioCtx.destination);

  osc.start();
  osc.stop(audioCtx.currentTime + duration);
}

function playEatSound() { playTone(600,0.08,0.07); }
function playHitSound() { playTone(120,0.12,0.08); }
function playPlantSound() { playTone(300,0.05,0.05); }

// ===== GAME STATE =====

let time = 0;
let paused = false;
let reversing = false;

let hostileChance = 0.5;

let score = 0;
let skillPoints = 0; // ★追加：スキルポイント

score += 10;
skillPoints++; // ★追加

let player = {
  x: canvas.width/2,
  y: canvas.height/2,
  size: 15,
  vx: 0,
  vy: 0
};

let echoes = [];
let recording = [];

let map = [];
const mapSize = 40;
const tileSize = 50;

// ===== INPUT =====

let keys = {};

document.addEventListener("keydown", e => {
  keys[e.code] = true;

  if (e.code === "KeyP") togglePause();
  if (e.code === "KeyR") toggleReverse();
  if (e.code === "Space") plantEcho();
});

document.addEventListener("keyup", e => {
  keys[e.code] = false;
});

// ===== SETTINGS =====

hostileSlider.oninput = () => {
  hostileChance = hostileSlider.value/100;
  hostileLabel.textContent = hostileSlider.value + "%";
};

// ===== MAP GENERATION =====

function generateMap() {
  map = [];

  for (let y=0;y<mapSize;y++){
    let row=[];

    for (let x=0;x<mapSize;x++){
      let v = Math.random();

      if (v < 0.1) row.push("wall");
      else if (v < 0.12) row.push("energy");
      else row.push("empty");
    }

    map.push(row);
  }
}

// ===== AI LEARNING =====

function createEchoAI(echo) {
  echo.ai = {
    aggression: Math.random(),
    curiosity: Math.random()
  };
}

function updateEchoAI(echo,pos) {
  if (!echo.hostile) return;

  let dx = player.x - pos.x;
  let dy = player.y - pos.y;
  let dist = Math.sqrt(dx*dx+dy*dy);

  if (dist < 200) {
    pos.x += dx * 0.01 * echo.ai.aggression;
    pos.y += dy * 0.01 * echo.ai.aggression;
  }
}

// ===== GAME FUNCTIONS =====

function togglePause(){ paused=!paused; }
function toggleReverse(){ reversing=!reversing; }

function plantEcho(){
  if (recording.length<30) return;

  let echo={
    path:[...recording],
    startTime:time,
    hostile:Math.random()<hostileChance,
    eaten:false
  };

  createEchoAI(echo);

  echoes.push(echo);
  recording=[];

  playPlantSound();
}

function resetGame(){
  player.x=canvas.width/2;
  player.y=canvas.height/2;
  player.size=15;
  player.vx=0;
  player.vy=0;

  echoes=[];
  recording=[];
  score=0;
  time=0;

  generateMap();
}

function getEchoPosition(echo){

  let t=time-echo.startTime;

  if(reversing) t=-t;

  let index=Math.abs(Math.floor(t))%echo.path.length;

  let base=echo.path[index];

  let pos={x:base.x,y:base.y};

  updateEchoAI(echo,pos);

  return pos;
}

function updatePlayer(){

  if(keys["ArrowLeft"]) player.vx-=0.4;
  if(keys["ArrowRight"]) player.vx+=0.4;
  if(keys["ArrowUp"]) player.vy-=0.4;
  if(keys["ArrowDown"]) player.vy+=0.4;

  player.vx*=0.9;
  player.vy*=0.9;

  player.x+=player.vx;
  player.y+=player.vy;
}

function physics(){

  echoes.forEach(e=>{

    if(e.eaten)return;

    let pos=getEchoPosition(e);

    let dx=player.x-pos.x;
    let dy=player.y-pos.y;

    let dist=Math.sqrt(dx*dx+dy*dy);

    if(dist<player.size+10){

      if(e.hostile){

        player.vx+=dx*0.03;
        player.vy+=dy*0.03;

        player.size-=0.1;

        playHitSound();

      }else{

        e.eaten=true;

        player.size+=2;

        score+=10;

        playEatSound();

      }

    }

  });

}

function update(){

  if(paused)return;

  if(reversing)time--;
  else time++;

  updatePlayer();

  recording.push({x:player.x,y:player.y});

  if(recording.length>300)recording.shift();

  physics();

  size.textContent=player.size.toFixed(1);
  score.textContent=Math.floor(score);
  echoCount.textContent=echoes.filter(e=>!e.eaten).length;

  state.textContent=paused?"PAUSED":reversing?"REVERSING":"RUNNING";
}

function drawMap(){

  for(let y=0;y<mapSize;y++){
  for(let x=0;x<mapSize;x++){

    if(map[y][x]==="wall"){

      ctx.fillStyle="#1f2933";

      ctx.fillRect(x*tileSize,y*tileSize,tileSize,tileSize);

    }

  }}
}

function drawEchoes(){

  echoes.forEach(e=>{

    if(e.eaten)return;

    let pos=getEchoPosition(e);

    drawCircle(pos.x,pos.y,10,e.hostile?"red":"lime");

  });

}

function drawCircle(x,y,s,c){

  ctx.fillStyle=c;

  ctx.beginPath();

  ctx.arc(x,y,s,0,Math.PI*2);

  ctx.fill();

}

function draw(){

  ctx.fillStyle="rgba(0,0,0,0.3)";

  ctx.fillRect(0,0,canvas.width,canvas.height);

  drawMap();

  drawEchoes();

  drawCircle(player.x,player.y,player.size,reversing?"yellow":"cyan");

}

function loop(){

  update();

  draw();

  requestAnimationFrame(loop);

}

// INIT

generateMap();
loop();



// ===== STORY + OBSERVER + EXISTENCE SYSTEM =====

let discoveredLogs = new Set();
let logTimer = 0;
let playerDead = false;
let observerActive = false;
let observerMessageShown = false;
let interventionTriggered = false;

const storyLogs = [
  { id:"log0", time:60, text:"記録 0.1\n存在を維持するには、残響を回収する必要がある。" },
  { id:"log1", echoes:3, text:"記録 0.7\n残響は無害であるとは限らない。時間は完全には保存されない。" },
  { id:"log2", score:50, text:"記録 1.3\n残響の一部は、記録より先に発生する。" },
  { id:"log3", reverse:true, text:"記録 3.0\n残響は時間ではなく、存在の痕跡から生成されている。" },
  { id:"log4", size:40, text:"記録 5.0\n残響は元の存在を再現しようとしている。" },
  { id:"log5", score:150, text:"記録 8.4\n元の存在は、すでに消失している可能性がある。" },
  { id:"log6", score:300, text:"記録 11.0\n観測対象は安定している。観測を継続する。" },
  { id:"log7", score:500, text:"記録 14.2\n現在の存在が最初の存在であったかは不明。" }
];

function showLog(text){
  const logDisplay = document.getElementById("logDisplay");
  logDisplay.innerText = text;
  logDisplay.style.display = "block";
  logTimer = 600;
}

function checkStoryTriggers(){

  storyLogs.forEach(log=>{

    if(discoveredLogs.has(log.id)) return;

    let unlocked = false;

    if(log.time && time > log.time) unlocked = true;
    if(log.echoes && echoes.length >= log.echoes) unlocked = true;
    if(log.score && score >= log.score) unlocked = true;
    if(log.size && player.size >= log.size) unlocked = true;
    if(log.reverse && reversing) unlocked = true;

    if(unlocked){
      discoveredLogs.add(log.id);
      showLog(log.text);
    }

  });

}

function updateObserver(){

  if(score > 200 && !observerActive){
    observerActive = true;
    showLog("記録 11.4\n観測者はまだここにいる。");
  }

}

function echoIntervention(){

  if(player.size < 8 && echoes.length > 0 && !interventionTriggered){

    interventionTriggered = true;

    let helper = echoes.find(e=>!e.hostile && !e.eaten);

    if(helper){

      player.size += 10;

      showLog("記録 12.0\n残響が存在維持を選択した。");

    }

  }

}

function checkPlayerDeath(){

  if(player.size <= 2 && !playerDead){

    playerDead = true;

    showLog(
      "記録 13.0\nオリジナルの消失を確認。\n残響による再構築を開始。"
    );

  }

}

// Override update
const originalUpdate = update;

update = function(){

  originalUpdate();

  checkStoryTriggers();
  updateObserver();
  echoIntervention();
  checkPlayerDeath();

checkAutonomousShift();
updateAutonomousEcho();
updateTitle();


  if(logTimer > 0){
    logTimer--;
    if(logTimer === 0){
      document.getElementById("logDisplay").style.display = "none";
    }
  }

};

// Override drawEchoes to add YOU markers
const originalDrawEchoes = drawEchoes;

drawEchoes = function(){

  echoes.forEach(e=>{

    if(e.eaten)return;

    let pos=getEchoPosition(e);

    drawCircle(pos.x,pos.y,10,e.hostile?"red":"lime");

    if(score > 300){
      ctx.fillStyle="white";
      ctx.font="10px sans-serif";
      ctx.fillText("YOU", pos.x-10, pos.y-15);
    }

  });

};

// Override draw player disappearance
const originalDraw = draw;

draw = function(){

  ctx.fillStyle="rgba(0,0,0,0.3)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  drawMap();
  drawEchoes();

  if(!playerDead){
    drawCircle(player.x,player.y,player.size,reversing?"yellow":"cyan");
  }

};




// ===== PERSISTENT EXISTENCE SYSTEM =====

// Save echo history as "past lives"
function saveExistence(){

  const existence = {
    echoes: echoes.map(e=>({
      path: e.path,
      hostile: e.hostile
    })),
    score: score,
    timestamp: Date.now()
  };

  localStorage.setItem("temporalEchoExistence", JSON.stringify(existence));

}

// Load past existence
function loadExistence(){

  const data = localStorage.getItem("temporalEchoExistence");

  if(!data) return;

  try{

    const existence = JSON.parse(data);

    existence.echoes.forEach(old=>{

      echoes.push({
        path: old.path,
        startTime: time,
        hostile: false,
        eaten:false,
        ai:{
          aggression:0.2,
          curiosity:0.8
        },
        persistent:true
      });

    });

    showLog(
      "記録 15.0\n以前の存在の残響を検出。\n再統合を開始。"
    );

  }catch(e){
    console.warn("Existence load failed", e);
  }

}

// Save periodically
setInterval(saveExistence, 5000);

// Load at startup
setTimeout(loadExistence, 1000);



// ===== AUTONOMOUS ECHO CONTROL =====

let autonomousMode = false;
let autonomousEcho = null;

function checkAutonomousShift(){

  if(playerDead && echoes.length > 0 && !autonomousMode){

    autonomousMode = true;

    autonomousEcho = echoes.find(e=>!e.eaten);

    showLog(
      "記録 16.0\n制御は残響に移行した。"
    );

  }

}

function updateAutonomousEcho(){

  if(!autonomousMode || !autonomousEcho) return;

  const pos = getEchoPosition(autonomousEcho);

  player.x += (pos.x - player.x)*0.02;
  player.y += (pos.y - player.y)*0.02;

}



// ===== TITLE MUTATION SYSTEM =====

function updateTitle(){

  if(score > 400){
    document.title = "Temporal Echo Garden: Observation Active";
  }

  if(score > 800){
    document.title = "Temporal Echo Garden: Reconstruction Phase";
  }

  if(playerDead){
    document.title = "Temporal Echo Garden: Echo Persistence";
  }

}


</script>

</body>
</html>
